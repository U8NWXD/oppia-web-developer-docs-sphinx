<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Apache Beam jobs &mdash; Oppia Web Contributor Documentation  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Writing state migrations" href="Writing-state-migrations.html" />
    <link rel="prev" title="Backend" href="backend-reference.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Oppia Web Contributor Documentation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Core documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Oppia%27s-Mission.html">Oppia’s Mission</a></li>
<li class="toctree-l1"><a class="reference internal" href="Oppia%27s-Mission.html#vision">Vision</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/oppia/oppia/blob/develop/.github/CODE_OF_CONDUCT.md">Code of Conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="get-involved.html">Get Involved</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developing Oppia</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Frequently-Asked-Questions.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="Installing-Oppia.html">Installing Oppia</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tips-for-common-IDEs.html">Tips for common IDEs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Make-a-pull-request.html">Make a pull request</a></li>
<li class="toctree-l1"><a class="reference internal" href="Pull-requests-at-Oppia.html">Pull requests at Oppia</a></li>
<li class="toctree-l1"><a class="reference internal" href="Get-help.html">Get help</a></li>
<li class="toctree-l1"><a class="reference internal" href="Learning-Resources.html">Learning resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="Git-cheat-sheet.html">Git cheat sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="get-started.html">Get started with the code base</a></li>
<li class="toctree-l1"><a class="reference internal" href="coding-guidelines.html">Coding guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="release.html">Release process</a></li>
<li class="toctree-l1"><a class="reference internal" href="Events-Team.html">Oppia Events team</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Oppiabot.html">Oppiabot</a></li>
<li class="toctree-l1"><a class="reference internal" href="frontend-reference.html">Frontend</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="backend-reference.html">Backend</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Apache Beam jobs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#table-of-contents">Table of contents</a></li>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#running-apache-beam-jobs">Running Apache Beam Jobs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#apache-beam-job-architecture">Apache Beam Job Architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pipelines"><code class="docutils literal notranslate"><span class="pre">Pipeline</span></code>s</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pvalues"><code class="docutils literal notranslate"><span class="pre">PValue</span></code>s</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ptransforms"><code class="docutils literal notranslate"><span class="pre">PTransform</span></code>s</a></li>
<li class="toctree-l4"><a class="reference internal" href="#runners"><code class="docutils literal notranslate"><span class="pre">Runner</span></code>s</a></li>
<li class="toctree-l4"><a class="reference internal" href="#high-level-guidelines">High-level Guidelines</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#case-studies">Case studies</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#case-study-countallmodelsjob">Case study: <code class="docutils literal notranslate"><span class="pre">CountAllModelsJob</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#case-study-schemamigrationjob">Case Study: <code class="docutils literal notranslate"><span class="pre">SchemaMigrationJob</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Writing-state-migrations.html">Writing state migrations</a></li>
<li class="toctree-l2"><a class="reference internal" href="Writing-audit-jobs.html">Writing audit jobs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Writing-new-one-off-jobs-using-map-reduce.html">Writing new one off jobs using map reduce</a></li>
<li class="toctree-l2"><a class="reference internal" href="Calculating-statistics.html">Calculating statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Creating-and-modifying-storage-models.html">Creating and modifying storage models</a></li>
<li class="toctree-l2"><a class="reference internal" href="Writing-Validators-for-storage-models.html">Writing validators for storage models</a></li>
<li class="toctree-l2"><a class="reference internal" href="Coding-for-speed-in-GAE.html">Coding for speed in GAE</a></li>
<li class="toctree-l2"><a class="reference internal" href="Adding-static-assets.html">Adding static assets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Wipeout-Implementation.html">Wipeout implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Wipeout-Implementation.html#wipeout-design">Wipeout design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Notes-on-NDB-Datastore-Transactions.html">Notes on NDB datastore transactions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Adding-new-translations-for-i18n.html">Adding new translations for i18n</a></li>
<li class="toctree-l1"><a class="reference internal" href="How-to-develop-for-i18n.html">How to develop for i18n</a></li>
<li class="toctree-l1"><a class="reference internal" href="Webpack.html">Webpack</a></li>
<li class="toctree-l1"><a class="reference internal" href="extension-reference.html">Extension frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="Advice-on-creating-explorations.html">Advice on creating explorations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Oppia-ml-Extension.html">Oppia-ml Extension</a></li>
<li class="toctree-l1"><a class="reference internal" href="Mobile-development.html">Mobile development</a></li>
<li class="toctree-l1"><a class="reference internal" href="Mobile-device-testing.html">Mobile device testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="Performance-Testing.html">Performance testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="Build-process.html">Build process</a></li>
<li class="toctree-l1"><a class="reference internal" href="Team-Structure.html">Team structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="playbooks.html">Playbooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="past-events.html">Past Events</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Oppia Web Contributor Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="backend-reference.html">Backend</a> &raquo;</li>
      <li>Apache Beam jobs</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/Apache-Beam-Jobs.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="apache-beam-jobs">
<h1>Apache Beam jobs<a class="headerlink" href="#apache-beam-jobs" title="Permalink to this headline"></a></h1>
<section id="table-of-contents">
<h2>Table of contents<a class="headerlink" href="#table-of-contents" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p><a class="reference external" href="#introduction">Introduction</a></p></li>
<li><p><a class="reference external" href="#running-apache-beam-jobs">Running Apache Beam Jobs</a></p></li>
<li><p><a class="reference external" href="#apache-beam-job-architecture">Apache Beam Job Architecture</a></p>
<ul>
<li><p><a class="reference external" href="#pipelines"><code class="docutils literal notranslate"><span class="pre">Pipeline</span></code>s</a></p></li>
<li><p><a class="reference external" href="#pvalues"><code class="docutils literal notranslate"><span class="pre">PValue</span></code>s</a></p></li>
<li><p><a class="reference external" href="#ptransforms"><code class="docutils literal notranslate"><span class="pre">PTransform</span></code>s</a></p>
<ul>
<li><p><a class="reference external" href="#pardo-and-dofn"><code class="docutils literal notranslate"><span class="pre">ParDo</span></code> and <code class="docutils literal notranslate"><span class="pre">DoFn</span></code></a></p></li>
<li><p><a class="reference external" href="#map-and-flatmap"><code class="docutils literal notranslate"><span class="pre">Map</span></code> and <code class="docutils literal notranslate"><span class="pre">FlatMap</span></code></a></p></li>
<li><p><a class="reference external" href="#filter"><code class="docutils literal notranslate"><span class="pre">Filter</span></code></a></p></li>
<li><p><a class="reference external" href="#groupbykey"><code class="docutils literal notranslate"><span class="pre">GroupByKey</span></code></a></p></li>
<li><p><a class="reference external" href="#example-of-using-groupbykeyfilter-and-flatmap">Example of using <code class="docutils literal notranslate"><span class="pre">GroupByKey</span></code>,<code class="docutils literal notranslate"><span class="pre">Filter</span></code>, and <code class="docutils literal notranslate"><span class="pre">FlatMap</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#runners"><code class="docutils literal notranslate"><span class="pre">Runner</span></code>s</a></p></li>
<li><p><a class="reference external" href="#high-level-guidelines">High-level Guidelines</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#case-studies">Case studies</a></p>
<ul>
<li><p><a class="reference external" href="#case-study-countallmodelsjob">Case study: <code class="docutils literal notranslate"><span class="pre">CountAllModelsJob</span></code></a></p></li>
<li><p><a class="reference external" href="#case-study-schemamigrationjob">Case Study: <code class="docutils literal notranslate"><span class="pre">SchemaMigrationJob</span></code></a></p></li>
</ul>
</li>
</ul>
</section>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline"></a></h2>
<p><a class="reference external" href="https://beam.apache.org/">Apache Beam</a> is used by Oppia to perform large-scale datastore operations. There are two types of operations:</p>
<ul class="simple">
<li><p><strong>Batch</strong>: Operations that are designed to be executed <em>once</em> on the current state of the datastore. Here are some examples:</p>
<ul>
<li><p>Count the number of models in the datastore.</p></li>
<li><p>Update a property across all models.</p></li>
<li><p>Validate the relationships between models.</p></li>
</ul>
</li>
<li><p><strong>Continuous</strong>: Operations that are designed to run <em>indefinitely</em> by reacting to updates to the datastore. Here are some examples:</p>
<ul>
<li><p>Updating the top 10 answers to a lesson every time a new answer is submitted.</p></li>
<li><p>Generating notifications for the events that users have subscribed to whenever those events change.</p></li>
</ul>
</li>
</ul>
<p>If you’re already familiar with Apache Beam or are eager to start writing a new job, jump to the <a class="reference external" href="#case-studies">case studies</a>. Otherwise, you can read the whole page. If you still have questions after reading, take a look at the <a class="reference external" href="https://beam.apache.org/documentation/programming-guide/">Apache Beam Programming Guide</a> for more details.</p>
</section>
<section id="running-apache-beam-jobs">
<h2>Running Apache Beam Jobs<a class="headerlink" href="#running-apache-beam-jobs" title="Permalink to this headline"></a></h2>
<p>These instructions assume you are running a local development server. If you are a release coordinator running these jobs on the production or testing servers, you should already have been granted the “Release Coordinator” role, so you can skip steps 1-3.</p>
<ol class="simple">
<li><p>Sign in as an administrator (<a class="reference external" href="https://github.com/oppia/oppia/wiki/How-to-access-Oppia-webpages#log-in-as-a-super-administrator">instructions</a>).</p></li>
<li><p>Navigate to <strong>Admin Page &gt; Roles Tab</strong>.</p></li>
<li><p>Add the “Release Coordinator” role to the username you are signed in with.</p></li>
<li><p>Navigate to http://localhost:8181/release-coordinator, then to the <strong>Beam Jobs tab</strong>.</p></li>
<li><p>Search for your job and then click the <strong>Play button</strong>.</p></li>
<li><p>Click “Start new job”.</p></li>
</ol>
<p><img alt="Screen recording showing how to run jobs" src="https://user-images.githubusercontent.com/5094060/128743997-70cca5f9-0b76-4294-806e-f65f5df5be95.gif" /></p>
</section>
<section id="apache-beam-job-architecture">
<h2>Apache Beam Job Architecture<a class="headerlink" href="#apache-beam-job-architecture" title="Permalink to this headline"></a></h2>
<p>Conceptually, an Apache Beam job is just a bunch of steps, each of which transforms some input data into some output data. For example, if you wanted to count how many interactions are in all of Oppia’s explorations, you could break that task down into a series of transformations:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.--------------. Count interactions .--------. Sum .-------.
| Explorations | -----------------&gt; | Counts | --&gt; | Total |
&#39;--------------&#39;                    &#39;--------&#39;     &#39;-------&#39;
</pre></div>
</div>
<p>For more complicated tasks, Apache Beam supports tasks whose transformations form a <a class="reference external" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graph</a>, or “DAG.” These are just graphs with no cycles. For example, if you wanted to find the ratio of interactions to cards, you could use this DAG:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.--------------. Count interactions .-------. Sum .------------------.
| Explorations | -----------------&gt; | Count | --&gt; | Num Interactions |
&#39;--------------&#39;                    &#39;-------&#39;     &#39;------------------&#39;
       |                                                    |
       |                                                    |
       |                                                    |
       | Count cards .-------. Sum .-----------.            |
       &#39;-----------&gt; | Count | --&gt; | Num Cards |------------+
                     &#39;-------&#39;     &#39;-----------&#39;            |
                                                            |
                            .----------------------. Divide |
                            | Interactions / Cards | &lt;------&#39;
                            &#39;----------------------&#39;
</pre></div>
</div>
<p>Note that the first example we saw, while linear, is still a DAG!</p>
<p>In Apache Beam, all jobs are represented as these DAGs. The nodes are represented as <a class="reference external" href="#pvalues"><code class="docutils literal notranslate"><span class="pre">PValue</span></code></a> objects, and the edges are represented as <a class="reference external" href="#ptransforms"><code class="docutils literal notranslate"><span class="pre">PTransform</span></code></a> objects. <a class="reference external" href="#pipelines"><code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a> objects manage the DAGs, and <a class="reference external" href="#runners"><code class="docutils literal notranslate"><span class="pre">Runner</span></code></a> objects actually execute the jobs.</p>
<p>Next, we’ll look at each of these components in more detail.</p>
<section id="pipelines">
<h3><code class="docutils literal notranslate"><span class="pre">Pipeline</span></code>s<a class="headerlink" href="#pipelines" title="Permalink to this headline"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Pipeline</span></code>s manage the “DAG” of <code class="docutils literal notranslate"><span class="pre">PValue</span></code>s and the <code class="docutils literal notranslate"><span class="pre">PTransform</span></code>s that compute them.</p>
<p>For example, here’s a schematic representation of a <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> that counts the number of occurrences of every word in an input file and writes those counts to an output file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.------------. io.ReadFromText(fname) .-------. FlatMap(str.split)
| Input File | ---------------------&gt; | Lines | -----------------.
&#39;------------&#39;                        &#39;-------&#39;                  |
                                                                 |
   .----------------. combiners.Count.PerElement() .-------.     |
.- | (word, count)s | &lt;--------------------------- | Words | &lt;---&#39;
|  &#39;----------------&#39;                              &#39;-------&#39;
|
| MapTuple(lambda word, count: &#39;%s: %d&#39; % (word, count)) .------------.
&#39;------------------------------------------------------&gt; | &quot;word: #&quot;s |
                                                         &#39;------------&#39;
                                                                |
                         .-------------. io.WriteToText(ofname) |
                         | Output File | &lt;----------------------&#39;
                         &#39;-------------&#39;
</pre></div>
</div>
<p>Here’s the code for this job:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">WordCountJob</span><span class="p">(</span><span class="n">base_jobs</span><span class="o">.</span><span class="n">JobBase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">ofname</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span>
            <span class="o">|</span> <span class="s1">&#39;Generate Lines&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">ReadFromText</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="o">|</span> <span class="s1">&#39;Generate Words&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">FlatMap</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">split</span><span class="p">)</span>
            <span class="o">|</span> <span class="s1">&#39;Generate (word, count)s&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">combiners</span><span class="o">.</span><span class="n">Count</span><span class="o">.</span><span class="n">PerElement</span><span class="p">()</span>
            <span class="o">|</span> <span class="s1">&#39;Generate &quot;word: #&quot;s&#39;</span> <span class="o">&gt;&gt;</span> <span class="p">(</span>
                <span class="n">beam</span><span class="o">.</span><span class="n">MapTuple</span><span class="p">(</span><span class="k">lambda</span> <span class="n">word</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">count</span><span class="p">)))</span>
            <span class="o">|</span> <span class="s1">&#39;Write to Output File&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">beam</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">WriteToText</span><span class="p">(</span><span class="n">ofname</span><span class="p">)</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>You might be wondering what’s going on with the <code class="docutils literal notranslate"><span class="pre">|</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> operators. In Python, objects can change how operators apply to them. Apache Beam has changed what the <code class="docutils literal notranslate"><span class="pre">|</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> operators do, so <code class="docutils literal notranslate"><span class="pre">|</span></code> doesn’t perform an OR operation anymore. Instead, <code class="docutils literal notranslate"><span class="pre">|</span></code> is a synonym for calling a <code class="docutils literal notranslate"><span class="pre">PCollection</span></code>’s <code class="docutils literal notranslate"><span class="pre">.apply()</span></code> method with a <code class="docutils literal notranslate"><span class="pre">PTransform</span></code> to create a new <code class="docutils literal notranslate"><span class="pre">PCollection</span></code>. <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> lets you name a <code class="docutils literal notranslate"><span class="pre">PTransform</span></code> step, which helps document your job. Note that at the very beginning, we also use <code class="docutils literal notranslate"><span class="pre">|</span></code> between the pipeline object and a <code class="docutils literal notranslate"><span class="pre">PTransform</span></code> to start building the job.</p>
</section>
<section id="pvalues">
<h3><code class="docutils literal notranslate"><span class="pre">PValue</span></code>s<a class="headerlink" href="#pvalues" title="Permalink to this headline"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">PCollection</span></code>s are the primary input and output <code class="docutils literal notranslate"><span class="pre">PValue</span></code>s used by <code class="docutils literal notranslate"><span class="pre">PTransform</span></code>s. They are a kind of <code class="docutils literal notranslate"><span class="pre">PValue</span></code> that represent a dataset of (virtually) any size, including unbounded and continuous datasets.</p>
<p><code class="docutils literal notranslate"><span class="pre">PBegin</span></code> and <code class="docutils literal notranslate"><span class="pre">PEnd</span></code> are “terminal” <code class="docutils literal notranslate"><span class="pre">PValue</span></code>s that signal that the value cannot be produced by an operation (<code class="docutils literal notranslate"><span class="pre">PBegin</span></code>) or that no operation can act on the value (<code class="docutils literal notranslate"><span class="pre">PEnd</span></code>). For example, a <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> object is a <code class="docutils literal notranslate"><span class="pre">PBegin</span></code>, and the output of a write operation is a <code class="docutils literal notranslate"><span class="pre">PEnd</span></code>.</p>
</section>
<section id="ptransforms">
<h3><code class="docutils literal notranslate"><span class="pre">PTransform</span></code>s<a class="headerlink" href="#ptransforms" title="Permalink to this headline"></a></h3>
<p>Recall that <code class="docutils literal notranslate"><span class="pre">PTransform</span></code>s represent the “edges” of the DAG and convert <code class="docutils literal notranslate"><span class="pre">PValue</span></code>s into other <code class="docutils literal notranslate"><span class="pre">PValue</span></code>s.</p>
<section id="pardo-and-dofn">
<h4><code class="docutils literal notranslate"><span class="pre">ParDo</span></code> and <code class="docutils literal notranslate"><span class="pre">DoFn</span></code><a class="headerlink" href="#pardo-and-dofn" title="Permalink to this headline"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">ParDo</span></code> is the most flexible <code class="docutils literal notranslate"><span class="pre">PTransform</span></code>. It accepts <code class="docutils literal notranslate"><span class="pre">DoFn</span></code>s, which are simple functions, as arguments and applies them to all elements of the input <code class="docutils literal notranslate"><span class="pre">PCollection</span></code> in parallel. It also accepts functions and lambda functions as arguments. It is analogous to the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">do_fn</span> <span class="o">=</span> <span class="n">DoFn</span><span class="p">()</span>
<span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">pcoll</span><span class="p">:</span>
    <span class="n">do_fn</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice that the return value from the <code class="docutils literal notranslate"><span class="pre">DoFn</span></code> is not used. However, it’s possible for the DoFn to hold onto state in more advanced implementations.</p>
</section>
<section id="map-and-flatmap">
<h4><code class="docutils literal notranslate"><span class="pre">Map</span></code> and <code class="docutils literal notranslate"><span class="pre">FlatMap</span></code><a class="headerlink" href="#map-and-flatmap" title="Permalink to this headline"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">beam.Map</span></code> is an operation that transforms each item in a <code class="docutils literal notranslate"><span class="pre">PCollection</span></code> into a new value using a plain-old function. It is analogous to the following code (where <code class="docutils literal notranslate"><span class="pre">fn</span></code> is the transformation function):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_pcoll</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">pcoll</span><span class="p">:</span>
    <span class="n">new_pcoll</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
<span class="k">return</span> <span class="n">new_pcoll</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">beam.FlatMap</span></code> is a similar transformation, but it <em>flattens</em> the output <code class="docutils literal notranslate"><span class="pre">PCollection</span></code> into a single output <code class="docutils literal notranslate"><span class="pre">PCollection</span></code>. It is analogous to the following code (where <code class="docutils literal notranslate"><span class="pre">fn</span></code> is the transformation function):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_pcoll</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">pcoll</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">sub_value</span> <span class="ow">in</span> <span class="n">fn</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="n">new_pcoll</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_value</span><span class="p">)</span>
<span class="k">return</span> <span class="n">new_pcoll</span>
</pre></div>
</div>
</section>
<section id="filter">
<h4><code class="docutils literal notranslate"><span class="pre">Filter</span></code><a class="headerlink" href="#filter" title="Permalink to this headline"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">beam.Filter</span></code> returns a new <code class="docutils literal notranslate"><span class="pre">PCollection</span></code> with all the elements of an input <code class="docutils literal notranslate"><span class="pre">PCollection</span></code>, so long as calling a specified filtering function on the element returned True. It is analogous to the following code (for filtering function <code class="docutils literal notranslate"><span class="pre">fn</span></code>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_pcoll</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">pcoll</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">fn</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="n">new_pcoll</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="k">return</span> <span class="n">new_pcoll</span>
</pre></div>
</div>
</section>
<section id="groupbykey">
<h4><code class="docutils literal notranslate"><span class="pre">GroupByKey</span></code><a class="headerlink" href="#groupbykey" title="Permalink to this headline"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">beam.GroupByKey</span></code> is useful when you need to perform an operation on elements that share a common property. It takes an input <code class="docutils literal notranslate"><span class="pre">PCollection</span></code> of <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code> elements and returns a mapping from each <code class="docutils literal notranslate"><span class="pre">key</span></code> to all the <code class="docutils literal notranslate"><span class="pre">values</span></code> that were associated with that <code class="docutils literal notranslate"><span class="pre">key</span></code>. It is analogous to the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">groups</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pcoll</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pcolls_to_group</span><span class="p">):</span>
    <span class="c1"># NOTE: Each PCollection must have (key, value) pairs as elements.</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">pcoll</span><span class="p">:</span>
        <span class="c1"># Items from each PCollection are grouped under the same key and</span>
        <span class="c1"># bucketed into their corresponding index.</span>
        <span class="n">groups</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="k">return</span> <span class="n">groups</span>
</pre></div>
</div>
</section>
<section id="example-of-using-groupbykey-filter-and-flatmap">
<h4>Example of using <code class="docutils literal notranslate"><span class="pre">GroupByKey</span></code>,<code class="docutils literal notranslate"><span class="pre">Filter</span></code>, and <code class="docutils literal notranslate"><span class="pre">FlatMap</span></code><a class="headerlink" href="#example-of-using-groupbykey-filter-and-flatmap" title="Permalink to this headline"></a></h4>
<p>For example, in our validation jobs we compute two <code class="docutils literal notranslate"><span class="pre">PCollection</span></code>s:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Tuples of (ModelKey, True) for each model in the datastore that exists.</span>
<span class="n">existing_models_pcoll</span> <span class="o">=</span> <span class="o">...</span>
<span class="c1"># Tuples of (ModelKey, str) for each error message that should be reported when</span>
<span class="c1"># the corresponding model instance does not exist.</span>
<span class="n">errors_if_missing_pcoll</span> <span class="o">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>To generate a report, we use <code class="docutils literal notranslate"><span class="pre">GroupByKey</span></code> to pair the messages to the existing models.</p>
<p>After this step, we can filter out the pairs where a model existed and report the errors that are left over.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">error_pcoll</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">(</span>
        <span class="c1"># A PCollection of Tuple[ModelKey, bool]. A ModelKey identifies an</span>
        <span class="c1"># individual model in the datastore.</span>
        <span class="n">existing_models_pcoll</span><span class="p">,</span>
        <span class="c1"># A PCollection of Tuple[ModelKey, str]. Each item corresponds to an</span>
        <span class="c1"># error that should be reported when the corresponding instance does not</span>
        <span class="c1"># exist.</span>
        <span class="n">errors_if_missing_pcoll</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># Returns a PCollection of Tuple[ModelKey, Tuple[List[bool], List[str]]].</span>
    <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">GroupByKey</span><span class="p">()</span>
    <span class="c1"># Discards ModelKey from the PCollection.</span>
    <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">Values</span><span class="p">()</span>
    <span class="c1"># Only keep groupings that indicate that the model is missing.</span>
    <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">Filter</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">exist_bools</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">exist_bools</span><span class="p">))</span>
    <span class="c1"># Discard the bools and flatten the results into a PCollection of strings.</span>
    <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">FlatMap</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">errors</span><span class="p">):</span> <span class="n">errors</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="runners">
<h3><code class="docutils literal notranslate"><span class="pre">Runner</span></code>s<a class="headerlink" href="#runners" title="Permalink to this headline"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Runner</span></code>s provide the <code class="docutils literal notranslate"><span class="pre">run()</span></code> method used to visit every node (<code class="docutils literal notranslate"><span class="pre">PValue</span></code>) in the pipeline’s DAG by executing the edges (<code class="docutils literal notranslate"><span class="pre">PTransform</span></code>s) to compute their values.  At Oppia, we use <code class="docutils literal notranslate"><span class="pre">DataflowRunner</span></code> to have our <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code>s run on the <a class="reference external" href="https://cloud.google.com/dataflow">Google Cloud Dataflow service</a>.</p>
</section>
<section id="high-level-guidelines">
<h3>High-level Guidelines<a class="headerlink" href="#high-level-guidelines" title="Permalink to this headline"></a></h3>
<p><strong>TL;DR</strong>: Inherit from <code class="docutils literal notranslate"><span class="pre">base_jobs.JobBase</span></code> and override the <code class="docutils literal notranslate"><span class="pre">run()</span></code> method.</p>
<ul>
<li><p>The <code class="docutils literal notranslate"><span class="pre">run()</span></code> method must return a <code class="docutils literal notranslate"><span class="pre">PCollection</span></code> of <code class="docutils literal notranslate"><span class="pre">JobRunResult</span></code> instances.</p>
<ul>
<li><p>In English, this means that <strong>the job <em>must</em> report <em>something</em> about what was done during its execution.</strong> For example, this can be the errors it discovered or the number of successful operations it was able to perform. <strong>Empty results are forbidden!</strong></p>
<p>If you don’t think your job has any results worth reporting, then just print a “Success” metric with the number of models it processed.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">JobRunResult</span></code> outputs should answer the following questions:</p>
<ul class="simple">
<li><p>Did the job run without any problems? How and why do I know?</p></li>
<li><p>How much work did the job manage to do?</p></li>
<li><p>If the job encountered a problem, what caused it?</p></li>
</ul>
</li>
</ul>
</li>
<li><p>When writing new jobs, prefer splitting boilerplate into new, small, and simple <code class="docutils literal notranslate"><span class="pre">PTransform</span></code> subclasses. Then, after unit testing them, combine them liberally in your job’s <code class="docutils literal notranslate"><span class="pre">run()</span></code> method.</p>
<ul class="simple">
<li><p>Keep the job class and the <code class="docutils literal notranslate"><span class="pre">PTransform</span></code>s it uses in the same file, unless you plan on reusing them in future jobs. If you <em>do</em> plan on reusing the job, then ask your reviewer for guidance on how to organize it.</p></li>
</ul>
</li>
<li><p>Never modify input values. If you need to make changes to an input value, then <a class="reference external" href="https://github.com/oppia/oppia/blob/4d2f639869e57fbeaada414d923cae83eb0e082e/jobs/job_utils.py#L37-L63">clone it first</a>.</p></li>
</ul>
</section>
</section>
<section id="case-studies">
<h2>Case studies<a class="headerlink" href="#case-studies" title="Permalink to this headline"></a></h2>
<p>The case studies are sorted in order of increasing complexity. Study the one that best suits your needs.</p>
<p>If none of them help you implement your job, you may request a new one by adding a comment to <a class="reference external" href="https://github.com/oppia/oppia/issues/13190">#13190</a> with answers to the following questions:</p>
<ul class="simple">
<li><p>Why do I want a new case study?</p></li>
<li><p>Why are the current case studies insufficient?</p></li>
<li><p>What answers would the “perfect” case study provide?</p></li>
</ul>
<p>Then we’ll start write a new Case Study to help you, and future contributors, as soon as we can (&#64;brianrodri will always notify you of how long it’ll take).</p>
<section id="case-study-countallmodelsjob">
<h3>Case study: <code class="docutils literal notranslate"><span class="pre">CountAllModelsJob</span></code><a class="headerlink" href="#case-study-countallmodelsjob" title="Permalink to this headline"></a></h3>
<p><strong>Difficulty:</strong> Trivial</p>
<p><strong>Key Concepts:</strong></p>
<ul class="simple">
<li><p>Fetching NDB models</p></li>
<li><p>Counting elements in a <code class="docutils literal notranslate"><span class="pre">PCollection</span></code></p></li>
<li><p>Creating <code class="docutils literal notranslate"><span class="pre">JobRunResult</span></code> values</p></li>
<li><p>Job registration</p></li>
</ul>
<hr class="docutils" />
<p>We’ll start by writing a boilerplate <code class="docutils literal notranslate"><span class="pre">PTransform</span></code> which accepts models as input, and returns <code class="docutils literal notranslate"><span class="pre">(kind,</span> <span class="pre">#)</span></code> tuples (where <code class="docutils literal notranslate"><span class="pre">kind</span></code> is the name of the model’s class, as a string).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">jobs</span> <span class="kn">import</span> <span class="n">job_utils</span>
<span class="kn">from</span> <span class="nn">jobs.types</span> <span class="kn">import</span> <span class="n">job_run_result</span>

<span class="kn">import</span> <span class="nn">apache_beam</span> <span class="k">as</span> <span class="nn">beam</span>


<span class="k">class</span> <span class="nc">CountModels</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">PTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the number of models after grouping them by their &quot;kind&quot;.</span>

<span class="sd">    Kind is a unique identifier given to all models. In practice, the following</span>
<span class="sd">    always holds:</span>

<span class="sd">        job_utils.get_model_kind(FooModel) == &#39;FooModel&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_pcoll</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method PTransform subclasses must implement.</span>

<span class="sd">        Args:</span>
<span class="sd">            model_pcoll: PCollection[base_models.BaseModel]. The collection of</span>
<span class="sd">                models to count.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PCollection[Tuple[str, int]]. The (kind, count) tuples corresponding</span>
<span class="sd">            to the input PCollection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">model_pcoll</span>
            <span class="c1"># &quot;Map&quot; every model to its kind. Analogous to the code:</span>
            <span class="c1"># [job_utils.get_model_kind(model) for model in model_pcoll]</span>
            <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="n">job_utils</span><span class="o">.</span><span class="n">get_model_kind</span><span class="p">)</span>
            <span class="c1"># Built-in PTransform that reduces a collection of values into</span>
            <span class="c1"># (value, # discovered) tuples.</span>
            <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">combiners</span><span class="o">.</span><span class="n">Count</span><span class="o">.</span><span class="n">PerElement</span><span class="p">()</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>Next, we’ll write the job which applies the <code class="docutils literal notranslate"><span class="pre">PTransform</span></code> to every model in the datastore. We can keep both the <code class="docutils literal notranslate"><span class="pre">PTransform</span></code> and the job in the same file, since they are so tightly coupled. Unit tests can focus on one or the other.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">core.platform</span> <span class="kn">import</span> <span class="n">models</span>
<span class="kn">from</span> <span class="nn">jobs</span> <span class="kn">import</span> <span class="n">base_jobs</span>
<span class="kn">from</span> <span class="nn">jobs.io</span> <span class="kn">import</span> <span class="n">ndb_io</span>

<span class="n">datastore_services</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Registry</span><span class="o">.</span><span class="n">import_datastore_services</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">CountAllModelsJob</span><span class="p">(</span><span class="n">base_jobs</span><span class="o">.</span><span class="n">JobBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Counts every model in the datastore.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">query_everything</span> <span class="o">=</span> <span class="n">datastore_services</span><span class="o">.</span><span class="n">query_everything</span><span class="p">()</span>
        <span class="n">all_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span> <span class="o">|</span> <span class="n">ndb_io</span><span class="o">.</span><span class="n">GetModels</span><span class="p">(</span><span class="n">query_everything</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">all_models</span>
            <span class="o">|</span> <span class="n">CountModels</span><span class="p">()</span>
            <span class="c1"># We&#39;ll convert the tuples into `JobRunResult` instances, where the</span>
            <span class="c1"># stdout field is used to store the tuple&#39;s value.</span>
            <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="n">job_run_result</span><span class="o">.</span><span class="n">JobRunResult</span><span class="o">.</span><span class="n">as_stdout</span><span class="p">)</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>Finally, we’ll import this job into the registry file. Let’s assume the name of
the file was <code class="docutils literal notranslate"><span class="pre">jobs/count_all_models_jobs.py</span></code>.</p>
<div class="highlight-diff notranslate"><div class="highlight"><pre><span></span>  # file: jobs/registry.py

  from jobs import base_jobs
  from jobs import base_validation_jobs
<span class="gi">+ from jobs import count_all_models_jobs</span>
</pre></div>
</div>
</section>
<section id="case-study-schemamigrationjob">
<h3>Case Study: <code class="docutils literal notranslate"><span class="pre">SchemaMigrationJob</span></code><a class="headerlink" href="#case-study-schemamigrationjob" title="Permalink to this headline"></a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Key Concepts:</strong></p>
<ul class="simple">
<li><p>Getting and Putting NDB models</p></li>
<li><p>Partitioning one <code class="docutils literal notranslate"><span class="pre">PCollection</span></code> into many <code class="docutils literal notranslate"><span class="pre">PCollection</span></code>s.</p></li>
<li><p>Returning variable outputs from a <code class="docutils literal notranslate"><span class="pre">DoFn</span></code></p></li>
</ul>
<hr class="docutils" />
<p>Let’s start by listing the specification of a schema migration job:</p>
<ul class="simple">
<li><p>We can assume:</p>
<ul>
<li><p>The schema version of a model is in the closed range <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">N]</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the latest version.</p></li>
<li><p>All migration functions are implemented in terms of taking <code class="docutils literal notranslate"><span class="pre">n</span></code> to <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p></li>
</ul>
</li>
<li><p>Our job should conform to the following requirements:</p>
<ul>
<li><p>Models should only be put into storage after successfully migrating to v<code class="docutils literal notranslate"><span class="pre">N</span></code>.</p></li>
<li><p>Models that were already at v<code class="docutils literal notranslate"><span class="pre">N</span></code> should be reported separately.</p></li>
</ul>
</li>
</ul>
<p>Often, when jobs are relatively complicated, it’s helpful to begin by sketching a diagram of what you want the job to do. We recommend using pen and paper or a whiteboard, but in this wiki page we use ASCII art to keep the document self-contained. For example, here’s a diagram for this job:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.--------------. Partition(lambda model: model.schema_version)
| Input Models | ---------------------------------------------.
&#39;--------------&#39;                                              |
                                             .-----------.    |
                    .----------------------- | Model @v1 | &lt;--|
                    |                        &#39;-----------&#39;    |
                    |                                         |
                    | ParDo(MigrateToNextVersion())           |
                     &gt;-----------------------------.          |
                    |                              |          |
                    |                              v          |
                    |                        .-----------.    |
                    &#39;----------------------- | Model ... | &lt;--&#39;
                                             &#39;-----------&#39;
                                                   |
                                                   v
                                             .-----------.
                                             | Model @vN |
                                             &#39;-----------&#39;
                                                   |
                 .-----------.  ndb_io.PutModels() |
                 | Datastore | &lt;-------------------&#39;
                 &#39;-----------&#39;
</pre></div>
</div>
<blockquote>
<div><p>TIP: You don’t need to know what the names of the <code class="docutils literal notranslate"><span class="pre">PTransform</span></code>s (edges) used in a diagram are. It’s easy to look up the appropriate <code class="docutils literal notranslate"><span class="pre">PTransform</span></code> after drawing the diagram.</p>
</div></blockquote>
<p>There’s a lot of complexity here, so we’ll need many <code class="docutils literal notranslate"><span class="pre">PTransform</span></code>s to write our job. We’ll focus on the most interesting one: the loop to migrate models to the next version.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MigrateToNextVersion</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">DoFn</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_model</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">input_model</span><span class="o">.</span><span class="n">schema_version</span> <span class="o">&lt;</span> <span class="n">ExplorationModel</span><span class="o">.</span><span class="n">LATEST_SCHEMA_VERSION</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">job_utils</span><span class="o">.</span><span class="n">clone_model</span><span class="p">(</span><span class="n">input_model</span><span class="p">)</span>
            <span class="n">exp_services</span><span class="o">.</span><span class="n">migrate_to_next_version</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">model</span>


<span class="k">class</span> <span class="nc">MigrateToLatestVersion</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">PTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Diagram:</span>

<span class="sd">    .--------------. Partition(lambda model: model.schema_version)</span>
<span class="sd">    | Input Models | ---------------------------------------------.</span>
<span class="sd">    &#39;--------------&#39;                                              |</span>
<span class="sd">                                                 .-----------.    |</span>
<span class="sd">                        .----------------------- | Model @v1 | &lt;--|</span>
<span class="sd">                        |                        &#39;-----------&#39;    |</span>
<span class="sd">                        |                                         |</span>
<span class="sd">                        | ParDo(MigrateToNextVersion())           |</span>
<span class="sd">                         &gt;-----------------------------.          |</span>
<span class="sd">                        |                              |          |</span>
<span class="sd">                        |                              v          |</span>
<span class="sd">                        |                        .-----------.    |</span>
<span class="sd">                        &#39;----------------------- | Model ... | &lt;--&#39;</span>
<span class="sd">                                                 &#39;-----------&#39;</span>
<span class="sd">                                                       |</span>
<span class="sd">                                                       v</span>
<span class="sd">                                                 .-----------.</span>
<span class="sd">                                                 | Model @vN |</span>
<span class="sd">                                                 &#39;-----------&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exp_model_pcoll</span><span class="p">):</span>
        <span class="n">models_by_schema_version</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">exp_model_pcoll</span>
            <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">Partition</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">model</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">schema_version</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">ExplorationModel</span><span class="o">.</span><span class="n">LATEST_SCHEMA_VERSION</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">do_fn</span> <span class="o">=</span> <span class="n">MigrateToNextVersion</span><span class="p">()</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">models_by_schema_version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="n">do_fn</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">models_at_ith_version</span> <span class="ow">in</span> <span class="n">models_by_schema_version</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">models_to_migrate</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">updated_models</span><span class="p">,</span> <span class="n">models_at_ith_version</span><span class="p">)</span>
                <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">Flatten</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">models_to_migrate</span> <span class="o">|</span> <span class="n">beam</span><span class="o">.</span><span class="n">FlatMap</span><span class="p">(</span><span class="n">do_fn</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that this implementation won’t work as-is since we focused on the step where we upgrade the models. To get this fully working, we’d need to write a <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> that handles loading in the models and writing the upgraded models back to the datastore.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="backend-reference.html" class="btn btn-neutral float-left" title="Backend" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Writing-state-migrations.html" class="btn btn-neutral float-right" title="Writing state migrations" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, The Oppia Authors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>